import os
import json
import random
import string
import subprocess
import datetime
import telebot
from threading import Lock

# --- ‚öôÔ∏è C·∫§U H√åNH H·ªÜ TH·ªêNG ---
BOT_TOKEN = "7022711443:AAHPixbTjnocW3LWgpW6gsGep-mCScOzJvM"
ADMIN_ID = 7550813603
IPV6_SUBNET = "2401:2420:0:102f"
NETWORK_INTERFACE = "eth0"
PROXY_USERNAME = "vtoan5516"
PORT_RANGE_START = 10000
PORT_RANGE_END = 60000
PROXY_LIFETIME_DAYS = 30
REGENERATE_THRESHOLD = 200 # S·ªë proxy h·∫øt h·∫°n ƒë·ªÉ k√≠ch ho·∫°t t·∫°o m·ªõi

# --- üìÇ ƒê∆Ø·ªúNG D·∫™N FILE ---
DATA_DIR = "/opt/proxy_manager"
PROXY_DATA_FILE = os.path.join(DATA_DIR, "proxy_data.json")
PROXY_CONFIG_FILE = "/etc/3proxy/3proxy.cfg"
LOG_FILE = "/var/log/3proxy/3proxy.log"

# Kh·ªüi t·∫°o bot v√† Lock ƒë·ªÉ tr√°nh xung ƒë·ªôt d·ªØ li·ªáu
bot = telebot.TeleBot(BOT_TOKEN)
data_lock = Lock()

# --- üïµÔ∏è H√ÄM KI·ªÇM TRA ADMIN ---
def is_admin(message):
    return message.from_user.id == ADMIN_ID

# --- üì¶ H√ÄM QU·∫¢N L√ù D·ªÆ LI·ªÜU PROXY (JSON) ---
def load_proxy_data():
    with data_lock:
        if not os.path.exists(PROXY_DATA_FILE):
            return {"proxies": [], "used_ports": []}
        try:
            with open(PROXY_DATA_FILE, 'r') as f:
                return json.load(f)
        except (json.JSONDecodeError, FileNotFoundError):
            return {"proxies": [], "used_ports": []}

def save_proxy_data(data):
    with data_lock:
        with open(PROXY_DATA_FILE, 'w') as f:
            json.dump(data, f, indent=4)

# --- üåç H√ÄM M·∫†NG & H·ªÜ TH·ªêNG ---
def get_public_ipv4():
    try:
        # L·∫•y IP public c·ªßa VPS
        result = subprocess.run(['curl', '-s', 'ifconfig.me'], capture_output=True, text=True, check=True)
        return result.stdout.strip()
    except Exception as e:
        print(f"L·ªói khi l·∫•y IPv4 public: {e}")
        return "127.0.0.1" # IP d·ª± ph√≤ng n·∫øu l·ªói

PUBLIC_IPV4 = get_public_ipv4()

def generate_random_ipv6():
    # T·∫°o ng·∫´u nhi√™n 4 kh·ªëi cu·ªëi c·ªßa ƒë·ªãa ch·ªâ IPv6
    return f"{IPV6_SUBNET}:{random.randint(0, 0xffff):04x}:{random.randint(0, 0xffff):04x}:{random.randint(0, 0xffff):04x}:{random.randint(0, 0xffff):04x}"

def generate_random_password(length=2):
    # T·∫°o m·∫≠t kh·∫©u ng·∫´u nhi√™n 2 ch·ªØ c√°i th∆∞·ªùng
    return ''.join(random.choice(string.ascii_lowercase) for _ in range(length))

def update_system_ips(proxies_to_add, proxies_to_remove):
    print(f"Adding {len(proxies_to_add)} IPs, Removing {len(proxies_to_remove)} IPs.")
    # Ch·∫°y l·ªánh h·ªá th·ªëng ƒë·ªÉ x√≥a IP c≈©
    for proxy in proxies_to_remove:
        subprocess.run(['ip', '-6', 'addr', 'del', f"{proxy['ipv6']}/128", 'dev', NETWORK_INTERFACE], capture_output=True)
    
    # Ch·∫°y l·ªánh h·ªá th·ªëng ƒë·ªÉ th√™m IP m·ªõi
    for proxy in proxies_to_add:
        subprocess.run(['ip', '-6', 'addr', 'add', f"{proxy['ipv6']}/128", 'dev', NETWORK_INTERFACE], capture_output=True)

def generate_3proxy_config_and_reload():
    data = load_proxy_data()
    # C√°c d√≤ng c·∫•u h√¨nh c∆° b·∫£n cho 3proxy
    config_lines = [
        "nserver 8.8.8.8",
        "nserver 8.8.4.4",
        "nscache 65536",
        "timeouts 1 5 30 60 180 1800 15 60",
        "daemon",
        f"log {LOG_FILE}",
        "logformat \"-L%t.%.%N -p%p -u%U -c%C -r%R -e%E\"", # Format log ƒë·ªÉ parse
        "auth strong",
    ]
    
    # L·ªçc ra c√°c proxy ch∆∞a h·∫øt h·∫°n ƒë·ªÉ ƒë∆∞a v√†o config
    active_proxies = [p for p in data['proxies'] if p['status'] != 'expired']

    for proxy in active_proxies:
        config_lines.append(f"users {proxy['username']}:CL:{proxy['password']}")
        config_lines.append(f"allow {proxy['username']}")
        # D√≤ng quan tr·ªçng: √°nh x·∫° port v√† IP v√†o/ra
        config_lines.append(f"proxy -6 -s0 -n -a -p{proxy['port']} -i{PUBLIC_IPV4} -e{proxy['ipv6']}")

    with open(PROXY_CONFIG_FILE, 'w') as f:
        f.write("\n".join(config_lines))
        
    print("Reloading 3proxy service...")
    # Gi·∫øt ti·∫øn tr√¨nh c≈© v√† kh·ªüi ƒë·ªông l·∫°i v·ªõi config m·ªõi
    subprocess.run(['killall', '3proxy'], capture_output=True)
    subprocess.run(['/usr/local/bin/3proxy', PROXY_CONFIG_FILE], check=True)
    print("3proxy reloaded.")

# --- ‚ú® H√ÄM LOGIC CH√çNH ---
def create_new_proxies(quantity: int):
    data = load_proxy_data()
    newly_created_proxies = []
    
    for _ in range(quantity):
        # T√¨m m·ªôt port ch∆∞a ƒë∆∞·ª£c s·ª≠ d·ª•ng
        while True:
            port = random.randint(PORT_RANGE_START, PORT_RANGE_END)
            if port not in data['used_ports']:
                data['used_ports'].append(port)
                break
        
        proxy_info = {
            "ipv4": PUBLIC_IPV4,
            "port": port,
            "ipv6": generate_random_ipv6(),
            "username": PROXY_USERNAME,
            "password": generate_random_password(),
            "status": "unused", # Tr·∫°ng th√°i ban ƒë·∫ßu: ch∆∞a d√πng
            "creation_time": datetime.datetime.now().isoformat(),
            "first_used_time": None
        }
        data['proxies'].append(proxy_info)
        newly_created_proxies.append(proxy_info)

    save_proxy_data(data)
    
    # C·∫≠p nh·∫≠t h·ªá th·ªëng (th√™m IP, reload 3proxy)
    update_system_ips(newly_created_proxies, [])
    generate_3proxy_config_and_reload()
    
    return newly_created_proxies

def check_proxies_and_regenerate():
    print(f"Running hourly check at {datetime.datetime.now()}...")
    data = load_proxy_data()
    
    # 1. ƒê·ªçc log ƒë·ªÉ ph√°t hi·ªán "l·∫ßn d√πng ƒë·∫ßu ti√™n"
    try:
        with open(LOG_FILE, 'r') as f:
            logs = f.readlines()
        
        # T·∫°o m·ªôt map ƒë·ªÉ tra c·ª©u nhanh c√°c proxy ch∆∞a active
        unused_proxies_map = {str(p['port']): p for p in data['proxies'] if p['status'] == 'unused'}
        if unused_proxies_map:
            for log_line in logs:
                # Parse log ƒë·ªÉ t√¨m port ƒë∆∞·ª£c s·ª≠ d·ª•ng
                port_used = None
                if "-p" in log_line:
                    try:
                        port_used = log_line.split("-p")[1].split(" ")[0]
                    except IndexError:
                        continue
                
                if port_used and port_used in unused_proxies_map:
                    print(f"Proxy on port {port_used} detected first use. Updating status.")
                    unused_proxies_map[port_used]['status'] = 'active'
                    unused_proxies_map[port_used]['first_used_time'] = datetime.datetime.now().isoformat()
    except FileNotFoundError:
        print("Log file not found, skipping first-use detection.")
        
    # 2. Ki·ªÉm tra v√† ƒë√°nh d·∫•u c√°c proxy ƒë√£ h·∫øt h·∫°n 30 ng√†y
    now = datetime.datetime.now()
    proxies_to_remove_from_iface = []

    for proxy in data['proxies']:
        if proxy['status'] == 'active' and proxy['first_used_time']:
            first_used_time = datetime.datetime.fromisoformat(proxy['first_used_time'])
            if now > first_used_time + datetime.timedelta(days=PROXY_LIFETIME_DAYS):
                if proxy['status'] != 'expired':
                    print(f"Proxy on port {proxy['port']} has expired.")
                    proxy['status'] = 'expired'
                    proxies_to_remove_from_iface.append(proxy)

    # N·∫øu c√≥ proxy m·ªõi h·∫øt h·∫°n, x√≥a IP c·ªßa n√≥ kh·ªèi card m·∫°ng
    if proxies_to_remove_from_iface:
        update_system_ips([], proxies_to_remove_from_iface)

    # 3. T·ª± ƒë·ªông t√°i t·∫°o n·∫øu s·ªë proxy h·∫øt h·∫°n ƒë·∫°t ng∆∞·ª°ng
    expired_proxies = [p for p in data['proxies'] if p['status'] == 'expired']
    if len(expired_proxies) >= REGENERATE_THRESHOLD:
        print(f"Expired proxy count ({len(expired_proxies)}) reached threshold ({REGENERATE_THRESHOLD}). Regenerating...")
        
        # D·ªçn d·∫πp: X√≥a h·∫≥n c√°c proxy h·∫øt h·∫°n kh·ªèi CSDL
        data['proxies'] = [p for p in data['proxies'] if p['status'] != 'expired']
        expired_ports = {p['port'] for p in expired_proxies}
        data['used_ports'] = [p for p in data['used_ports'] if p not in expired_ports]
        
        save_proxy_data(data)
        
        # T·∫°o 2000 proxy m·ªõi
        new_proxies = create_new_proxies(2000)
        
        # G·ª≠i th√¥ng b√°o v√† file cho admin
        bot.send_message(ADMIN_ID, f"‚ôªÔ∏è H·ªá th·ªëng ƒë√£ t·ª± ƒë·ªông t√°i t·∫°o 2000 proxy m·ªõi do c√≥ {len(expired_proxies)} proxy h·∫øt h·∫°n.")
        send_proxy_list_to_admin(ADMIN_ID, new_proxies, "new_proxy_list.txt")

    save_proxy_data(data)
    # Xo√° tr·∫Øng file log sau m·ªói l·∫ßn ki·ªÉm tra ƒë·ªÉ tr√°nh file qu√° l·ªõn
    open(LOG_FILE, 'w').close()
    
    print("Hourly check finished.")

def send_proxy_list_to_admin(chat_id, proxies, filename):
    if not proxies:
        bot.send_message(chat_id, "Kh√¥ng c√≥ proxy n√†o ƒë·ªÉ hi·ªÉn th·ªã.")
        return
        
    list_content = "\n".join([f"{p['ipv4']}:{p['port']}:{p['username']}:{p['password']}" for p in proxies])
    
    with open(filename, "w") as f:
        f.write(list_content)
    
    with open(filename, "rb") as f:
        bot.send_document(chat_id, f)
    
    os.remove(filename)

# --- ü§ñ TELEGRAM BOT HANDLERS ---
@bot.message_handler(commands=['start', 'help'])
def send_welcome(message):
    if not is_admin(message): return
    help_text = (
        "Ch√†o Admin! T√¥i l√† bot qu·∫£n l√Ω Proxy IPv6.\n\n"
        "C√°c l·ªánh c√≥ s·∫µn:\n"
        "üîπ `/tao <s·ªë l∆∞·ª£ng>` - T·∫°o s·ªë l∆∞·ª£ng proxy m·ªõi.\n"
        "   *V√≠ d·ª•:* `/tao 2000`\n"
        "üîπ `/dashboard` - Hi·ªÉn th·ªã b·∫£ng ƒëi·ªÅu khi·ªÉn tr·∫°ng th√°i.\n"
        "üîπ `/ds_proxy` - G·ª≠i file danh s√°ch t·∫•t c·∫£ proxy ƒëang ho·∫°t ƒë·ªông.\n"
        "üîπ `/check` - Ch·∫°y ki·ªÉm tra v√† t√°i t·∫°o th·ªß c√¥ng."
    )
    bot.reply_to(message, help_text)

@bot.message_handler(commands=['tao'])
def handle_create_proxy(message):
    if not is_admin(message): return
    try:
        quantity = int(message.text.split()[1])
        if not 1 <= quantity <= 10000: raise ValueError("S·ªë l∆∞·ª£ng kh√¥ng h·ª£p l·ªá.")
            
        bot.reply_to(message, f"üöÄ B·∫Øt ƒë·∫ßu t·∫°o {quantity} proxy... Vui l√≤ng ch·ªù trong gi√¢y l√°t.")
        new_proxies = create_new_proxies(quantity)
        bot.send_message(message.chat.id, f"‚úÖ ƒê√£ t·∫°o th√†nh c√¥ng {quantity} proxy.")
        send_proxy_list_to_admin(message.chat.id, new_proxies, f"proxies_{quantity}.txt")
        
    except (IndexError, ValueError):
        bot.reply_to(message, "L·ªói c√∫ ph√°p. Vui l√≤ng s·ª≠ d·ª•ng: `/tao <s·ªë l∆∞·ª£ng>`")

@bot.message_handler(commands=['dashboard'])
def handle_dashboard(message):
    if not is_admin(message): return
    data = load_proxy_data()
    proxies = data.get('proxies', [])
    total = len(proxies)
    unused = len([p for p in proxies if p['status'] == 'unused'])
    active = len([p for p in proxies if p['status'] == 'active'])
    expired = len([p for p in proxies if p['status'] == 'expired'])
    
    last_check_time = datetime.datetime.now().strftime("%d/%m/%Y - %H:%M")
    
    dashboard_text = (
        f"üìä **T√¨nh tr·∫°ng Proxy hi·ªán t·∫°i:**\n"
        f"‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n"
